[[body]]

== Precise Event Sample Attribution ISA Extension (Sspesa)

The Sspesa extension defines a mechanism by which the hart will, upon Zihpm counter overflow, record a PC and metadata associated with the instruction to which the sampled event should be attributed.

=== Sspesa Profile Types and Sources of Error

Sspesa enables generating two types of performance profiles:

* *Event-based performance profiles* in which the weight of an instruction in the profile is approximately proportional to the number of times it was subjected to the event. Event-based profiles are most useful when tracking down the instructions responsible for a problematic performance event. For example, if an application suffers from many L1 data cache misses, a sorted event-based profile obtained for the data L1 cache miss performance event provides an ordered list of the instructions that are responsible for most L1 data cache misses.
* *Time-based performance profiles* in which the weight of an instruction in the profile is approximately proportional to its contribution to overall execution time. To obtain such a profile, Sspesa is configured to trigger on a cycle counter. Upon a cycle counter overflow, Sspesa records the PC of an instruction from which profiling software can approximate the instruction(s) that the core exposed the exection time of when the sample was taken. A sorted time-based profile orders an application's instructions according to their approximate impact on overall execution time, and is hence most useful as a first-pass approach for identifying application hot spots.

NOTE: _In contrast to Sspesa, Smpdis/Sspdis (see <<_precise_decoded_instruction_sampling_smpdissspdis>>) create profiles in which an instruction is represented proportionally to its execution count._

Performance profiles obtained through Sspesa are approximate for two reasons. The first is systematic error (or bias) which reduces profile accuracy by attributing a counter overflow to a different instruction than the one that caused it. For event-based profiles, implementations are required to support precise attribution (i.e., no bias) because this is the core purpose of the Sspesa extension. For example, upon an overflow in the L1 data cache miss event counter, an Sspesa implementation must report the PC of the instruction that caused the counter overflow.

Time-based profiles are more complicated because no specific instruction caused the cycle counter to overflow. A time-based profile is however most useful when each instruction is represented in the profile in proportion to its impact on overall execution time. To create a bias-free profile, the implementation must therefore attribute each sample to the address(es) of the instruction(s) that the core is exposing execution time of (i.e., retiring) in the cycle the counter overflows; this is known as time-proportional attribution. Systematic errors can hence be eliminated by adopting time-proportional attribution policies, but this may not always be desirable (e.g., due to implementation overheads). For this reason, Sspesa expects implementations to minimize attribution bias when creating time-based profiles.

Statistical (or random) error is the second reason why Sspesa profiles are approximate. The root cause of statistical error is that Sspesa samples the its CSRs. It is thus unavoidable and affect event-based and time-based profiles equally. Statistical error is however typically negligible when sampling at 4kHz (which is the default sampling frequency of perf). Unlike systematic error, statistical error goes down as sampling frequency is increased. If statistical error is percieved to be a problem, it can be mitigated by adopting a higher sampling frequency, but it comes at the cost of increased runtime overhead.

=== CSRs

==== Hardware Performance Monitor Sample PC Register (`shpmspc`)

`shpmspc` is an SXLEN-bit read/write register that holds a sample PC value.  `shpmspc` captures a PC value when a Zihpm counter (`mhpmcounter__i__`) overflows, such that `mhpmevent__i__`.OF transitions from 0 to 1 and `__x__ip`.LCOFIP transitions from 0 to 1 (where _x_ reflects the privilege mode to which LCOFIs are delegated).

NOTE: _The dependence on `__x__ip`.LCOFIP serves to ensure that only the first overflow leading to an LCOFI updates `shpmspc`.  If additional counters overflow before the LCOFI trap, the recorded sample PC is not overwritten.  This ensures that the sample PC is consistent with the point where CTR is frozen, if `__x__ctrctl`.LCOFIFRZ=1. The ID of the counter that caused the sample PC update is recorded in `shpmsdata`.CNTRID._

.Sample PC Register for SXLEN=64
[%unbreakable]
[wavedrom, , svg]
....
{reg: [
    {bits:  64, name: 'Sample PC'},
], config:{lanes: 1, hspace:1024}}
....

When counter _i_ is programmed to count a performance event that supports precise attribution, the sample PC value captured will be a PC value related to that of the instruction that caused the counter to overflow, such that the `shpmsdata` register and other state can be used to discern the PC of the causal instruction.  The precise relationship between the captured PC and the PC of the causal instruction is implementation-defined.

For events that do not support precise attribution, the instruction whose PC is captured in `shpmspc`, and that which is derived from `shpmspc`, `shpmsdata`, and any other applicable state, is implementation-defined.

NOTE: _For events that do not support precise attribution, implementations are expected to make "best effort" to ensure that the derived sample PC is the best option for event attribution.  For most cases, the PC of an instruction retiring in the cycle of overflow or, if no instructions retire in that cycle, the PC of the instruction that is next to retire is recommended._

`shpmspc` can be used by S-mode only when supervisor counter delegation is enabled (`menvcfg`.CDE=1), in which case only overflows of delegated counters update `shpmspc`.  When supervisor counter delegation is disabled (`menvcfg`.CDE=0), attempts to access `shpmspc` from S-mode raise an illegal instruction exception.

Attempts to access `shpmspc` from VS-mode mode raise a virtual instruction exception when supervisor counter delegation is enabled, and an illegal instruction exception when supervisor counter delegation is disabled.

`shpmspc` is a WARL register that must be able to hold all valid virtual addresses. It need not be capable of holding all possible invalid addresses. Prior to writing `shpmspc`, implementations may convert an invalid address into some other invalid address that `shpmspc` is capable of holding.

==== Hardware Performance Monitor Sample Metadata (`shpmsdata`)

`shpmsdata` is an SXLEN-bit read/write WARL register that holds sample metadata.  The CNTRID field holds the ID of the counter whose overflow caused the sample metadata to be captured. If more than one counter overflows simultaneously, CNTRID holds the ID of the numerically lowest counter.

NOTE: _As an example, for simultaneous overflow of `mhpmcounter5` and `mhpmcounter9`, CNTRID would hold 5._

The format of the remaining bits is implementation-defined, serving to provide any metadata necessary to derive the sample PC from `shpmspc` and any other relevant state.  For implementations where `shpmspc` captures the precise sample PC, or where no additional metadata is needed, the remaining `shpmsdata` bits may be hardwired to 0.

.Sample Metadata Register for SXLEN=64
[%unbreakable]
[wavedrom, , svg]
....
{reg: [
    {bits:  5, name: 'CNTRID'},
    {bits:  59, name: 'WARL', type: 1},
], config:{lanes: 1, hspace:1024}}
....

Access to `shpmsdata` matches that of `shpmspc` above, and `shpmsdata` captures sample metadata for the same cases where `shpmspc` captures a sample PC.

[NOTE]
====
_In modern, superscalar implementations, the microarchitecture may be optimized such that the full PC of each retired instruction is not maintained throughout the pipeline.  The `shpmsdata` register provides a standard means by which such implementations can provide precise attribution, using a reference PC (`shpmspc`) and custom metadata that can be used by implementation-specific software algorithms to discern the appropriate sample PC._
====

NOTE: _When creating time-based profiles, the value in `shpmspc` can be combined with implementation-specific metadata in `shpmsdata` and Control Transfer Records (Ssctr) to account for instruction parallelism by obtaining the addresses of all instructions that retired in the cycle the sample was taken. If Ssctr is not available, implementations should strive to avoid bias when selecting the value for `shpmspc`._

WARNING: _Should we say that software should default to using `shpmspc` as-is, if it does not know of any custom algorithm for using `shpmsdata`?  Though that could result in the appearance of support for precise-attribution that in fact is not precise.  Perhaps if `shpmsdata` is not hardcoded to 0 and no custom algorithm is reported then software shouldn't report support for precise attribution?_

== Precise Local Counter Overflow Interrupt ISA Extension (Ssplcofi)

The Ssplcofi extension guarantees that, for Zihpm counters programmed to count performance events that support precise attribution, any LCOFI that results from overflow of such a counter will have no skid.  The LCOFI trap will immediately follow the instruction that caused the counter to overflow, such that the exception PC (epc) will be that of the instruction immediately following the causal instruction.

Ssplcofi requries support for Sspesa, which provides a reliable means to discern the sample PC.  Because the causal instruction may be a jump or taken branch, the sample PC cannot be reliably discerned from the epc value.

WARNING: _Should we make any promises or recommendations for events that do not support precise attribution?  E.g., cycles?_

== Precise Decoded Instruction Sampling (Smpdis/Sspdis)

Extensions such as Sspesa and Ssplcofi allow users to perform event-based sampling with precise attribution to an instruction PC.  Smpdis/Sspdis takes a different approach, sampling decoded instructions rather than performance events.  The sampled instructions are chosen in the frontend portion of the pipeline, allowing runtime metadata to be collected by the hardware as the sampled instruction passes through the backend pipeline.  So while event-based sampling with precise attribution allows attributing a single event with an instruction, Precise Decoded Instruction Sampling (PDIS) allows collection of multiple events, latencies, and addresses associated with the instruction's execution.

Because sampled instructions are chosen before they execute, it is not known whether they will incur events of interest.  PDIS therefore includes a rich set of sample filtering options, wherein samples that meet the filter criteria are "qualified" and delivered to software, while others are discarded.  This keeps profiling overhead low, by avoiding the overhead of sample collection for uninteresting instructions.

The machine-level extension, Smpdis, encompasses all newly added CSRs and behavior modifications for a hart across all privilege levels. The corresponding supervisor-level extension, Sspdis, is essentially identical to Smpdis, except that it excludes machine-level CSRs and behaviors not intended to be directly accessible at the supervisor level.

NOTE: _When to use event-based sampling (like Sspesa or Ssplcofi) vs instruction-based sampling (Smpdis/Sspdis) is an art rather than a science.  Say more here._

[[pdiscsr]]
=== CSRs

[[pdisctl]]
==== Machine PDIS Control Register (`mpdisctl`)

The `mpdisctl` register is a 64-bit WARL register that configures the PDIS mechanism.  For RV32, bits 63:32 of `mpdisctl` can be accessed via the `mpdisctlh` CSR.

.Machine PDIS Control Register (`mpdisctl`)
[wavedrom, , svg]
....
{reg: [
    {bits:  3, name: 'SEL'},
    {bits: 29, name: 'HPM[31:3]'},
    {bits:  1, name: 'MEM'},
    {bits:  1, name: 'ACC'},
    {bits:  1, name: 'TS'},
    {bits:  1, name: 'PA'},
    {bits:  1, name: 'EPT'},
    {bits: 20, name: 'WARL', type: 1},
    {bits:  3, name: 'Custom'},
    {bits:  1, name: 'U'},
    {bits:  1, name: 'S'},
    {bits:  1, name: 'M'},
    {bits:  1, name: 'OF'},
], config:{lanes: 4, hspace:1024}}
....

[cols="15%,85%",options="header"]
|====
| Field | Description
| SEL | Selects the type(s) of decoded instructions to be counted and sampled.  Encodings are as follows.

0: All instructions.

1: Load instructions.

2: Store instructions.

3: Load & store instructions.

4: Control transfer instructions.

5..7: _Reserved_

| HPM[31:3] | Each HPM__i__ bit enables recording of whether the sampled instruction incurred the event selected in `mhpmevent__i__`.  Recording of events for HPM__i__ requires that counter __i__ is delegated to the same privilege mode as PDIS, that the selected event supports PDIS recording, and that the counter is enabled in the privilege mode in which the sampled instruction executes.
| MEM | When set, enables storing of sample records (<<samprec>>) to the PDIS Memory Buffer (<<membuff>>).  When cleared, sample records are instead written to `spdisdata__i__` registers (<<dataregs>>).
| ACC | Accelerate instruction selection after a sample is filtered out or otherwise discarded.  See <<sampsel>>.
| TS | Enable recording of a timestamp per record.  See <<samprec>>.
| PA | Enable recording the physical address of sampled explicit memory operations.  See <<samprec>>.
| EPT | Enable recording of the prior control transfer target.  See <<samprec>>.
| Custom[2:0] | WARL bits designated for custom use.  The value 0 must correspond to standard behavior.  See <<Custom Extensions>>.
| U  | Enable counting U-mode instructions.
| S  | Enable counting S-mode instructions.
| M  | Enable counting M-mode instructions.
| OF | PDIS counter overflow.
|====

NOTE: _The set of performance events with PDIS support is implementation-defined and should be discoverable via the implementation's performance event JSON file.  Events with the 'PdisSupported' (TBD) attribute set to true support PDIS._

The M bit is always writable.  The S and U bits are writable if the corresponding privilege mode is implemented.  Otherwise, an implementation may opt to hardwire to 0 any of the other fields described above.  The MEM and ACC fields may be hardwired to 0 or 1.

WARNING: _Should MEM always be hardcoded?  Is there a reason an implementation would want to support both output to CSRs and output to memory?_

The SEL field allows software to select the types of instructions to be counted and sampled.  The control transfer instruction type includes all instructions that can effect an explicit control transfer change, including branches, jumps, and trap returns.  It does not include instructions that effect a control transfer change as a result of a trap.  The load instruction type includes all instructions that perform an explicit load operation, the store instruction type includes all instructions that perform an explicit store, and the load & store instruction type includes instructions that perform an explicit load and/or an explicit store.

WARNING: _Should the SEL field be removed and replaced by the option of "promoting" the late instr type filtering to be early, as we did with control transfer type bits?_

The PDIS counter (`spdiscounter`.COUNT) counts decoded instructions based on SEL value, as well as the M, S, and U values in `mpdisctl`, and the S and U values in `vspdisctl`.  See <<pdiscnt>> for more details on PDIS counter behavior.

NOTE: _Filtering samples by instruction type can be done downstream, but that is less efficient as there may be many selected instructions of the wrong type that will be discarded.  By implementing this filtering at selection time, the sample discard rate will be reduced._

When the PDIS counter overflows, a decoded instruction is selected for sampling.  See <<sampsel>> for details on instruction selection.  As the selected instruction passes through the pipeline, sample data is collected by the hardware. For details on the data collected, see <<samprec>>. The PDIS counter is also reloaded to its initial value, counting towards the next sampled instruction.

NOTE: _It is not required that the instruction that caused overflow is selected, but it is recommended that implementations minimize any skid between the overflow instruction and the selected instruction._

When the instruction completes, either by retiring, trapping, or being flushed by an older mis-speculation, filtering is applied to the sample data.  See <<pdisfilt>> for details on sample filtering.  If the filter criteria are not met, the sample is discarded.  Otherwise, if the PDIS counter is not inhibited (see <<pdisinh>>), the sample is qualified.

If the selected instruction is a qualified sample, the sample is recorded.  If MEM=1, the sample record (see <<samprec>>) is written to memory (see <<membuff>>).  If MEM=0, the sample is recorded to CSRs (see <<dataregs>>).

If OF=0 and a sample is qualified, OF transitions to 1 and a local counter overflow interrupt (LCOFI) is pended.  If filtering is not applied to the sample (`spdisevmask`=0 and `spdisfilter`=0), and the sampled instruction neither traps nor is flushed, the LCOFI is guaranteed to be "skidless." Skidless implies that, in the absence of interrupt disabling, the LCOFI is taken before the next instruction in the same privilege mode retires.  This "skidless" LCOFI allows software to collect additional sample state (e.g., general purpose registers, call-stack addresses) before younger instructions can modify it.  For samples that do not meet the criteria that guarantees a skidless LCOFI, it is implementation-defined whether the LCOFI is skidless.

[[pdisinh]]
==== Machine Count Inhibit Register (`mcountinhibit`)

Bit 1 in `mcountinhibit` controls whether the PDIS counter, `spdiscounter`.COUNT, increments, and whether samples are recorded.  When `mcountinhibit`[1]=1, the PDIS counter does not increment, and active selected instructions (if any) do not record sample data.

WARNING: _We hope to add a general counter-freeze mechanism in the future that will allow the user to choose to inhibit counting for select counters during LCOFI handling.  Until then software will need to set `mcountinhibit`[1] to stop PDIS counting during the LCOFI handler._

==== Machine Environment Configuration Register (`menvcfg`)

Bit 59 is PDISS.  When set, the PDISS memory buffer is configured for use by supervisor software.  PDISS is used to select the trace write privilege and translation mechanism used by AMB, see Section 1.5 of the https://github.com/riscv/self-hosted-trace/releases[Self-hosted Trace Specification].

If `mpdisctl`.MEM is hardcoded to 0, PDISS is hardcoded to 0 as well.

NOTE: _Bit 59 is proposed._

==== Supervisor PDIS Control Register (`spdisctl`)

The `spdisctl` register provides supervisor mode access to a subset of `mpdisctl`.

Bit 62 in `spdisctl` is read-only 0. As a result, the M field in `mpdisctl` is not accessible through `spdisctl`. All other `mpdisctl` fields are accessible through `spdisctl`.

For RV32, bits 63:32 of `spdisctl` can be accessed via the `spdisctlh` CSR.

[[pdiscnt]]
==== Supervisor PDIS Counter Register (`spdiscounter`)

The `spdiscounter` register is a 64-bit WARL register that holds the PDIS counter, as well as the initial counter value used for hardware reload.  For RV32, bits 63:32 of `spdiscounter` can be accessed via the `spdiscounterh` CSR.

.Supervisor PDIS Counter Register (`spdiscounter`)
[wavedrom, , svg]
....
{reg: [
    {bits:  32, name: 'COUNT'},
    {bits:  32, name: 'INITVAL'},
], config:{lanes: 1, hspace:1024}}
....

[cols="15%,85%",options="header"]
|====
| Field | Description
| COUNT | PDIS counter value.
| INITVAL | PDIS counter initial value.
|====

The PDIS counter value, `spdiscounter`.COUNT, is incremented for each decoded instruction that matches the instruction type selected in `mpdisctl`.SEL, while in a privilege mode enabled in `mpdisctl`/`vspdisctl`.  Counting is inhibited when `mcountinhibit`[1]=1.

NOTE: _The PDIS counter is limited to 32 bits since, unlike Zihpm counters, it is used only for sampling, rather than for counting.  When Zihpm counters are used in counting mode they count all events for an application, which can run for minutes or more.  Sampling, on the other hand, requires counters only to count through the sample period, which is typically on the order of 100,000 instructions.  Shorter sample periods (higher sampling rates) are preferred for more accurate and detailed profiles, but minimizing sampling overhead can cause longer periods to be chosen._

Hardware writes the COUNT field with the value held in the INITVAL field when the PDIS counter overflows, such that a hardware update causes `spdiscounter`.COUNT[31] to transition from 1 to 0.

NOTE: _This harware counter reload mechanism is not guaranteed to be lossless.  The COUNT field may be incremented beyond 0 before the write occurs, and any event increments that occur in the same cycle as the write may be dropped.  Implementations are encouraged to minimize the incidence of skid and dropped counts, as these add noise to the sampling rate._

[[dataregs]]
==== Supervisor PDIS Sample Data Register Access

When `mpdisctl`.MEM=0, sample records are written to a set of indirect CSRs accessed using Sscsrind.  See <<samprec>> for details on the sample data.  These registers are populated only when a sampled instruction is a qualified sample.  The registers are mapped to record fields as follows.

.Sample Data Indirect CSR Mappings for RV64
[width="60%",options="header"]
|===
| `siselect` | Indirect Register | Record Field
.6+| 0x60 | `sireg` | pdishdrev
| `sireg2` | pdispc
| `sireg3` | pdistime
| `sireg4` | pdislat
| `sireg5` | pdisadr1
| `sireg6` | pdisadr2
.6+| 0x61 | `sireg` | _WPRI_
| `sireg2` | _WPRI_
| `sireg3` | 0
| `sireg4` | 0
| `sireg5` | 0
| `sireg6` | 0
|===

.Sample Data Indirect CSR Mappings for RV32
[width="60%",options="header"]
|===
| `siselect` | Indirect Register | Record Field
.6+| 0x60 | `sireg` | pdishdrev[31:0]
| `sireg2` | pdishdrev[63:32]
| `sireg3` | pdispc
| `sireg4` | pdistime
| `sireg5` | pdislat[31:0]
| `sireg6` | pdislat[63:32]
.6+| 0x61 | `sireg` | pdisadr1
| `sireg2` | pdisadr2
| `sireg3` | _WPRI_
| `sireg4` | _WPRI_
| `sireg5` | _WPRI_
| `sireg6` | _WPRI_
|===

If the H extension is implemented, the same mappings above apply to `vsireg__i__` when `vsiselect` holds 0x60 or 0x61.

If `mpdisctl`.MEM is hardcoded to 1, implying that the implementation only supports recording of sample data to memory, the PDIS Sample Data registers are not implemented.

WARNING: _I'd like to avoid the cost of saving/restoring these CSRs when MEM=1.  Can we recommend that SW clear them when setting MEM=1?  Or does HW need to make them ROZ?_

WARNING: _0x60 and 0x61 are proposed `*iselect` index values._

==== Supervisor PDIS Event Filter Mask Register (`spdisevmask`)

The `spdisevmask` register is a 64-bit WARL register whose value is used for filtering samples.  See <<pdisfilt>>.

.Supervisor PDIS Event Filter Mask Register (`spdisevmask`)
[wavedrom, , svg]
....
{reg: [
    {bits:  56, name: 'MASK'},
    {bits:  8, name: '0'},
], config:{lanes: 1, hspace:1024}}
....

Implementations may opt to hardwire some or all bits to 0.  For RV32, bits 63:32 of `spdisevmask` can be accessed via the `spdisevmaskh` CSR.

==== Supervisor PDIS Event Filter Match Register (`spdisevmatch`)

The `spdisevmatch` register is a 64-bit WARL register whose value is used for filtering samples.  See <<pdisfilt>>.

.Supervisor PDIS Event Filter Match Register (`spdisevmatch`)
[wavedrom, , svg]
....
{reg: [
    {bits:  56, name: 'MATCH'},
    {bits:  8, name: '0'},
], config:{lanes: 1, hspace:1024}}
....

Implementations may opt to hardwire some or all bits to 0.  For RV32, bits 63:32 of `spdisevmatch` can be accessed via the `spdisevmatchh` CSR.

==== Supervisor PDIS Filter Register (`spdisfilter`)

The `spdisfilter` register is a WARL register that allows the user to filter records based on fields other than those in pdishdrev.

.Supervisor PDIS Filter Register (`spdisfilter`)
[wavedrom, , svg]
....
{reg: [
    {bits: 12, name: 'THRESH'},
    {bits:  1, name: 'INV'},
    {bits:  3, name: 'LATSEL'},
    {bits: 48, name: 'WARL', type: 1},
], config:{lanes: 2, hspace:1024}}
....

[cols="15%,85%",options="header"]
|===
| Field | Description
| THRESH | The latency threshold to compare with the selected PDIS latency value (see <<pdislat>>).  The comparison evaluates to true if the latency value is greater than or equal to the threshold value.
| INV | When set, invert the result of the latency comparison.
| LATSEL | Selects the PDIS latency value for comparison.  Encodings are as follows.

0: Total latency

1: Dispatch latency

2: Issue latency

3: Execution latency

4: Oldest latency

See <<pdislat>> for details on the latency values.
|===

If latency filtering is not supported, `spdisfilter` should be read-only 0.  Otherwise, THRESH and INV must remain writable.  LATSEL may optionally be hardcoded to 0, implying that only filtering by "Total latency" is supported.

==== Supervisor PDIS AMB Control and Status (`spdisambcs`)

The `spdisambcs` register is the PDIS instatiation of the `sambcs` register defined by the https://github.com/riscv/self-hosted-trace/releases[Ssamb extension].  It is implemented only if `mpdisctl`.MEM is not hardcoded to 0.  See <<membuff>> for PDIS Memory Buffer details.

==== Supervisor PDIS AMB Address (`spdisambaddr`)

The `spdisambaddr` register is the PDIS instatiation of the `sambaddr` register defined in the Ssamb specification, see https://github.com/riscv/self-hosted-trace/releases[Ssamb extension].  It is implemented only if `mpdisctl`.MEM is not hardcoded to 0.  See <<membuff>> for PDIS Memory Buffer details.

For RV64 implementations, bits 6:0 are hardcoded to 0, while for RV32 implementations, bits 5:0 are hardcoded to 0.  This ensures that records are aligned to their size, see <<samprec>>.

==== Supervisor Counter Overflow Register (`scountovf`)

Bit 1 in `scountovf` reflects the value of the PDIS counter overflow bit, `mpdisctl`.OF.

==== Supervisor Count Inhibit Register (`scountinhibit`)

When PDIS is delegated from M-mode (`mstateen0`.PDIS=1) and counter delegation is enabled (`menvcfg`.CDE=1), `mcountinhibit`[1] is accessible from `scountinhibit`[1].  Otherwise `scountinhibit`[1] is read-only 0.

WARNING: _Before PDIS, `scountinhibit` provided access to `mcountinhibit` & `mcounteren`, allowing S-mode to inhibit only delegated counters.  Since PDIS isn't delegated through `mcounteren` (bit 1 controls read access to `time`), the PDIS bit has to be handled differently._

==== Hypervisor Environment Configuration Register (`henvcfg`)

Bit 59 is PDISV.  When `menvcfg`.PDISS and `henvcfg`.PDISV are set, the PDIS memory buffer is configured for use by a guest.  PDISV is used to select the trace write privilege and translation by AMB, see Section 1.5 of the https://github.com/riscv/self-hosted-trace/releases[Self-hosted Trace Specification].

If `mpdisctl`.MEM is hardcoded to 0, PDISV is hardcoded to 0 as well.

NOTE: _Bit 59 is proposed._

==== Virtual Supervisor PDIS Control Register (`vspdisctl`)

If the H extension is implemented, the `vspdisctl` register is a 64-bit WARL register that is VS-mode’s version of supervisor register `spdisctl`. When V=1, `vspdisctl` substitutes for the usual `spdisctl`, so instructions that normally read or modify `spdisctl` actually access `vspdisctl` instead.

`vspdisctl` provides access to `spdisctl` from VS-mode, with the exception of the following fields that have a different function in `vspdisctl`.

[cols="15%,85%",options="header"]
|===
| Field | Description
| PA | Enable recording the guest physical address of sampled explicit memory operations.  See <<samprec>>.
| S | Enable counting VS-mode instructions.
| U | Enable counting VU-mode instructions.
|===

NOTE: _If the implementation cannot provide the guest physical address (GPA) for sampled loads and/or stores, perhaps because the GPA is not stored in the TLB, the `vspdisctl`.PA bit should be hardcoded to 0._

For RV32, bits 63:32 of `vspdisctl` can be accessed via the `vspdisctlh` CSR.

[[stateen]]
=== State Enable Access Control

When Smstateen is implemented, the `mstateen0`.PDIS bit controls access to PDIS register state from privilege modes less privileged than M-mode.  When `mstateen0`.PDIS=1, supervisor level accesses to PDIS register state behave as described in <<CSRs>> above.  When `mstateen0`.PDIS=0 and the privilege mode is less privileged than M-mode, attempts to access `spdis*` or `vspdisctl` raise an illegal-instruction exception.

When `mstateen0`.PDIS=0, PDIS continues to be able to sample instructions executed in privilege modes less privileged than M-mode.

If the H extension is implemented and `mstateen0`.PDIS=1, the `hstateen0`.PDIS bit controls access to supervisor PDIS state (`spdis*`) when V=1.  `hstateen0`.PDIS is read-only 0 when `mstateen0`.PDIS=0.

When `mstateen0`.PDIS=1 and `hstateen0`.PDIS=1, VS-mode accesses to supervisor PDIS state behave as described in <<CSRs>> above.  When `mstateen0`.PDIS=1 and `hstateen0`.PDIS=0, VS-mode accesses to supervisor PDIS state raise a virtual-instruction exception.

When `hstateen0`.PDIS=0, PDIS continues to be able to sample instructions executed while V=1.

NOTE: _See Sscsrind for how bit 60 in `mstateen0` and `hstateen0` can also restrict access to `sireg*`/`siselect` and `vsireg*`/`vsiselect` from privilege modes less privileged than M-mode._

[[sampsel]]
=== Instruction Selection

PDIS selects instructions before they are dispatched to the backend (execution) pipeline.  Selection occurs when one of the following occurs.

1. The PDIS counter (<<pdiscnt>>) overflows while there is no PDIS sample active; or
2. A sample is discarded, due to backpressure or sample filtering, and `mpdisctl`.ACC=1.

A sampled instruction remains active until it either retires, traps, or is flushed by an older mis-speculation.  If the PDIS counter overflows while a sample is active, this is known as a collision, and the counter is simply reloaded without selecting an instruction.

NOTE: _To reduce the likelihood of collisions, implementations should recommend a minimum PDIS counter initial value.  For most implementations, this value should be approximately equal to the size of the out-of-order window._

An implementation may choose to break some complex instructions into a series of micro-operations (uops) for execution.  Such implementations may opt to sample only a single uop, rather than the full execution of the complex instruction.  The implication of such a choice is that the PDIS record fields will reflect only the execution of that uop, and not other uops within the same instruction flow.  In such cases, the pdishdrev.PARTIAL bit is set to 1.

For instructions that perform multiple explicit memory accesses, a single access must be selected for populating the data virtual address, data physical or guest physical address, DSRC, L1MISS, LLMISS, L1TLBMISS, and LLTLBMISS fields.  Optionally other sample record fields may also reflect only values associated with the selected memory access.  Which memory access is selected is implementation-defined.  These instructions always set pdishdrev.PARTIAL to 1.

An implementation may choose to fuse multiple instructions into a single uop for execution such that, if a fused instruction is selected for sampling, the sample record may reflect execution of instruction(s) other than that residing at the PDIS PC address.  The sample record in such cases sets pdishdrev.FUSED to 1.

NOTE: _It is strongly recommended that implementations avoid bias in instruction selection.  Always choosing an instruction from decoder 0, for instance, could bias selection towards branch targets, or other instructions that are more likely to use decoder 0.  Similarly, when selecting a single memory access from among multiple, avoiding bias to the degree possible will produce the most representative profile._

[[samprec]]
=== Sample Record

The sample record includes all of the sample data collected during execution of the sampled instruction.  For RV64 the record is 64 bytes, while for RV32 the record is 32 bytes.

.PDIS Sample Record for RV64
[cols="5%,90%,5%",options="header",grid=rows]
|===
| 63 || 0
3+^| PDIS Header and Events (pdishdrev)
3+^| PDIS Program Counter (pdispc)
3+^| PDIS Time (pdistime)
3+^| PDIS Latencies (pdislat)
3+^| PDIS Address 1 (pdisadr1)
3+^| PDIS Address 2 (pdisadr2)
3+^| _WPRI_
3+^| _WPRI_
|===

.PDIS Sample Record for RV32
[cols="5%,90%,5%",options="header",grid=rows]
|===
| 31 || 0
3+^| pdishdrev[31:0]
3+^| pdishdrev[63:32]
3+^| pdispc
3+^| time[31:0]
3+^| pdislat[31:0]
3+^| pdislat[63:32]
3+^| pdisadr1
3+^| pdisadr2
|===

WARNING: _The `time` register is 64b regardless of RV32/RV64, so this RV32 record only captures the lower half of `time`.  That okay?_

[[pdishdrev]]
==== PDIS Header and Events (pdishdrev)

This section holds the record format, and event information for the sampled instruction.  Any fields that are not populated for a given sample hold 0.

[[recevents]]
.PDIS Header and Events (pdishdrev)
[wavedrom, , svg]
....
{reg: [
    {bits:  3, name: 'TYPE'},
    {bits: 29, name: 'HPM[31:3]'},
    {bits:  1, name: 'FLUSHED'},
    {bits:  2, name: 'FLUSH'},
    {bits:  1, name: 'PARTIAL'},
    {bits:  1, name: 'FUSED'},
    {bits:  1, name: 'ITMISS'},
    {bits:  1, name: 'ICMISS'},
    {bits: 19, name: 'WPRI', type: 1},
    {bits:  3, name: 'SFMT'},
    {bits:  3, name: 'FMT'},
], config:{lanes: 8, hspace:1024}}
....

[cols="15%,85%",options="header"]
|===
| Field | Description
| TYPE | The type of instruction sampled.  The encoding values are as follows.

0: Other instruction (does not match any of the defined types below)

1: Load instruction

2: Store instruction

3: Load & store instruction

4: Control transfer instruction

5..7: _Reserved_

| HPM__i__ | When `mpdisctl`.HPM__i__=1 and other criteria are met (see <<pdisctl>>), set if the sampled instruction incurred the event selected in `mhpmevent__i__`.
| FLUSHED | When set, indicates that the sampled instruction did not retire, but instead was flushed due to an earlier mis-speculation.
| FLUSH | When FLUSHED=1, this field provides the type of flush that cleared the sampled instruction.  The encoding values are as follows.

0: Other

1: Branch misprediction

2: Memory ordering violation

3: _Reserved_
| PARTIAL | When set, indicates that the selected instruction was only partially sampled, such that some elements of the instruction's execution may not be captured in the sample data.  See <<sampsel>> for more details.
| FUSED | When set, indicates that the sampled instruction may have been fused with the instruction immediately preceding it, or immediately following it, such that artifacts of the adjacent, fused instruction may be visible in the sample data.  See <<sampsel>> for more details.
| ITMISS | When set, indicates that the fetch request for the sampled instruction incurred an ITLB miss.  Only the first instruction to be executed from the fetch line, either at offset 0 or the target of a control transfer, will set ITMISS.
| ICMISS | When set, indicates that the fetch request for the sampled instruction incurred an instruction cache miss.  Only the first instruction to be executed from the fetch line, either at offset 0 or the target of a control transfer, will set ICMISS.
| SFMT | Record sub-format.  For PDIS v1.0, this value is 0.  Changes to the sub-format imply backwards-compatible changes to the record; e.g., adding a new field to previously WPRI bits.
| FMT | Record format.  For PDIS v1.0, this value is 0.  Changes to the format are not backwards-compatible; e.g., legacy fields may be moved or redefined.
|===

The TYPE, FLUSHED, FMT, and SFMT fields are required, while other fields are optional.  Unimplemented fields should always report 0.

Additional sample data fields are included in PDIS Header & Events when the type is load, store, load & store, or control transfer instruction.  For load, store, and load & store instructions, the following sample data is collected in pdishdrev.

.PDIS Header and Events (pdishdrev) for Load and/or Store Instructions
[wavedrom, , svg]
....
{reg: [
    {bits:  3, name: 'TYPE=1,2,3'},
    {bits: 29, name: 'HPM[31:3]'},
    {bits:  1, name: 'FLUSHED'},
    {bits:  2, name: 'FLUSH'},
    {bits:  1, name: 'PARTIAL'},
    {bits:  1, name: 'FUSED'},
    {bits:  1, name: 'ITMISS'},
    {bits:  1, name: 'ICMISS'},
    {bits:  1, name: 'L1MISS'},
    {bits:  1, name: 'LLMISS'},
    {bits:  4, name: 'DSRC'},
    {bits:  1, name: 'L1TLBMISS'},
    {bits:  1, name: 'LLTLBMISS'},
    {bits: 11, name: 'WPRI', type: 1},
    {bits:  3, name: 'SFMT'},
    {bits:  3, name: 'FMT'},
], config:{lanes: 8, hspace:1024}}
....

[cols="20%,80%",options="header"]
|===
| Field | Description
| L1MISS | Data request missed the L1 cache.
| LLMISS | Data request missed the last-level cache.  Optional.
| DSRC | Data source.  Encodings for this field are implementation-defined.  Optional.
| L1TLBMISS | Address translation missed the L1 TLB.
| LLTLBMISS | Address translation missed the last-level TLB.
| Others | Defined in <<recevents>> above.
|===

The L1MISS and L1TLBMISS fields are required, while others are optional.

For control transfer instructions, the control transfer type is optionally captured, using a one-hot encoding that simplifies filtering for combinations of types.  The types match those defined by the Smctr/Ssctr and trace specifications.  Additionally, whether the transfer was mispredicted is captured.

.PDIS Header and Events (pdishdrev) for Control Transfer Instructions
[wavedrom, , svg]
....
{reg: [
    {bits:  3, name: 'TYPE=4'},
    {bits: 29, name: 'HPM[31:3]'},
    {bits:  1, name: 'FLUSHED'},
    {bits:  2, name: 'FLUSH'},
    {bits:  1, name: 'PARTIAL'},
    {bits:  1, name: 'FUSED'},
    {bits:  1, name: 'ITMISS'},
    {bits:  1, name: 'ICMISS'},
    {bits:  1, name: 'TRET'},
    {bits:  1, name: 'NTBR'},
    {bits:  1, name: 'TKBR'},
    {bits:  2, name: 'WPRI', type: 1},
    {bits:  1, name: 'INDCALL'},
    {bits:  1, name: 'DIRCALL'},
    {bits:  1, name: 'INDJMP'},
    {bits:  1, name: 'DIRJMP'},
    {bits:  1, name: 'CORSWAP'},
    {bits:  1, name: 'RET'},
    {bits:  1, name: 'INDLJMP'},
    {bits:  1, name: 'DIRLJMP'},
    {bits:  1, name: 'MISPRED'},
    {bits:  5, name: 'WPRI', type: 1},
    {bits:  3, name: 'SFMT'},
    {bits:  3, name: 'FMT'},
], config:{lanes: 8, hspace:1024}}
....

[cols="15%,85%",options="header"]
|===
| Field | Description
| TRET | Trap return.
| NTBR | Not-taken branch.
| TKBR | Taken branch.
| INDCALL | Indirect call.
| DIRCALL | Direct call.
| INDJMP | Indirect jump (without linkage).
| DIRJMP | Direct jump (without linkage).
| CORSWAP | Co-routine swap.
| RET | Function return.
| INDLJMP | Other indirect jump (with linkage).
| DIRLJMP | Other direct jump (with linkage).
| MISPRED | The control transfer was mispredicted.
| Others | Defined in <<recevents>> above.
|===

All of the fields defined for control transfer instructions above are optional.

NOTE: _As an example of using filtering to capture select combinations of control transfer types, to capture only transfers of type INDCALL, INDJMP, or INDLJMP, the mask and match filtering (see <<pdisevfilt>>) should be set to match 0s for all the excluded transfer type bits (DIRLJMP, RET, CORSWAP, DIRJMP, DIRCALL, TKBR, NTBR, and TRET), while leaving the bits for INDCALL, INDJMP, and INDLJMP unmasked._


==== PDIS Program Counter (pdispc)

This section holds the PC of the sampled instruction.

WARNING: _Could use upper 5 bit of pdispc for other things, since Sv57x4 defines widest VA as 59 bits._

[[pdislat]]
==== PDIS Latencies (pdislat)

This section holds the latency values collected during sampled instruction execution.  The format of this section is shown below.

.PDIS Latencies (pdislat)
[wavedrom, , svg]
....
{reg: [
    {bits: 12, name: 'TOTAL'},
    {bits: 12, name: 'DISPATCH'},
    {bits: 12, name: 'ISSUE'},
    {bits: 12, name: 'EXECUTION'},
    {bits: 12, name: 'OLDEST'},
    {bits:  1, name: 'DISPV'},
    {bits:  1, name: 'ISSV'},
    {bits:  1, name: 'EXECV'},
    {bits:  1, name: 'OLDV'},
], config:{lanes: 4, hspace:1024}}
....

[cols="15%,85%",options="header"]
|===
| Field | Description
| TOTAL | The latency from instruction selection to instruction retire, trap, or flush.
| DISPATCH | The latency from instruction selection to instruction dispatch to the backend.  This will capture any cycles during which backend stalls prevent dispatch.
| ISSUE | The latency from instruction dispatch until the instruction is issued for execution.  This will capture any cycles during which the instruction is waiting for dependencies to resolve, and waiting for availability of the execution unit.  For loads and stores, this includes the latency to translate the virtual address.
| EXECUTION | The latency from instruction issue until the instruction has completed execution and is ready to retire.  For loads and stores, this includes the latency to perform the memory access.
| OLDEST | The latency from when the instruction becomes the oldest unretired instruction until instruction retirement.
| DISPV | The DISPATCH field is valid.
| ISSV | The ISSUE field is valid.
| EXECV | The EXECUTION field is valid.
| OLDV | The OLDEST field is valid.
|===

TOTAL is a required field, while other latency fields are optional.  For any latency fields that are not implemented, both the latency field and the corresponding valid bit should report 0.

The definitions above were crafted such that Total latency = Dispatch latency + Issue latency + Execution latency + Retire latency.  The Retire latency, defined as the latency from execution completion until the instruction retires, is not captured because it can be derived from the others.

[NOTE]
====
_The dispatch point described above is intended to be shared with the Topdown analysis method, typically when instructions/uops are passed from the frontend (e.g., decoder outputs) to the backend (e.g., allocated into the ROB or other backend queue(s)).  Issue latency, then, includes all latency between this dispatch point and the point at which the instruction execution begins.  In a replay-based microarchitecture, this may cover multiple rounds of issue and replay by a scheduler, waiting for dependencies to resolve, the address to be translated, and any required hardware execution resources to come available.  Instruction execution describes the time during which a load or store's explicit memory request is outstanding, or during which a non-memory operation is being executed by an ALU or other execution unit._

_This gets more complicated for instructions that perform multiple operations, such as a load-op instruction, or an instruction that performs multiple loads.  For such instructions, the execution latency would ideally cover all cycles during which any of the constituent operations were executing, even if others are still awaiting issue or even dispatch.  Similarly, the issue latency would cover all cycles during which any of the constituent operations were awaiting issue, even if others are still awaiting dispatch.  For simplicity, implementations may opt to sample a single operation within the instruction, such that the events, addresses, and/or latencies recorded reflect only the single operation._
====

WARNING: _FIXME: if multi-uop insts are handled as described above some cycles will be double-counted; e.g. one uop is incrementing issue latency while another is incremented execution latency._

WARNING: _Some implementations may execute stores post-retirement.  This scheme does not capture the latency of that memory access.  That may be okay, since post-retire store accesses are off the critical path (don't hold up retire).  But they can occupy queue slots, cause stalls if queues fill, etc.  An altnernative would be to say that such stores are recorded until memory accesses complete?_

==== PDIS Time (pdistime)

When `mpdisctl`.TS=1 and `time` is readable in the privilege mode to which PDIS is delegated, this section holds the `time` value of the sample.  Otherwise the field value is 0.

NOTE: _To illustrate this scheme, if PDIS is delegated to S-mode (`mstateen0`.PDIS=1 and `hstateen0`.PDIS=0), then pdistime holds the `time` value if `time` can be read in S-mode (`mcounteren`[1]=1), otherwise it holds 0._

The `time` value should be captured as closely as possible to the time the sampled instruction retires, traps, or is flushed.

==== PDIS Address1 (pdisadr1)

If at least one virtual address, aside from the PC, is captured for this sample, it is held in pdisadr1.  Capturing an address (aside from PC) is optional.  If no virtual address is captured for this sample, pdisadr1 is 0.

If the record's FLUSHED bit is set, pdisadr1 optionally holds the PC of the instruction that caused the flush.  For a mispredict flush, pdisadr1 the PC of the branch or jump that mispredicted.  For a memory ordering violation flush, pdisadr1 is the PC of the load that incurred the violation.  For other flush sources, the value is implementation-defined.

If the instruction was not flushed and performs an explicit memory access, pdisadr1 is the data virtual address of the access.  See <<sampsel>> for how the data virtual address is chosen for multi-access instructions.

If the instruction was not flushed and is an indirect control transfer, which implies that the type is one of INDCALL, INDJMP, INDLJMP, RET, or CORSWAP, pdisadr1 holds the target PC of the transfer.  If the instruction is not flushed and is a direct control transfer, an implementation may optionally capture the target PC as pdisadr1.

WARNING: _Should pdisadr1/2 have valid bits, or is using 0 enough to indicate that no address is reported?_

==== PDIS Address2 (pdisadr2)

If an additional address is captured for this sample, aside from the PC and pdisadr1, it is held in pdisadr2.  Capturing a second address (aside from PC) is optional.  If no additional address is captured for this sample, pdisadr2 is 0.

If the record's FLUSHED bit is set, and the sampled instruction performs an explicit memory access, pdisadr2 may hold the data virtual address of the access.

NOTE: _The virtual address of the access may not be resolved by the time the instruction is flushed.  In such cases, pdisadr2 will hold 0._

If the instruction was not flushed and the instruction is of type load, store, or load & store, then:

* if the sampled instruction executed in VS-mode or VU-mode and `vspdisctl`.PA=1, pdisadr2 holds the data guest physical address to which the virtual address in pdisadr1 is mapped;
* otherwise, if `mpdisctl`.PA=1, pdisadr2 holds the data physical address to which the virtual address in pdisadr1 is mapped.

If the instruction was not flushed, the instruction is of type control transfer, and `mpdisctl`.EPT=1, pdisadr2 holds the target of the prior control transfer instruction.

[[pdisfilt]]
=== Sample Filtering

When sampled instructions retire, trap, or are flushed, the sample data collected can optionally be used to filter out (discard) uninteresting samples.

[[pdisevfilt]]
==== Event Filtering

The `spdisevmatch` and `spdisevmask` registers can be used to discard samples whose instruction type and/or events do not match desired values.  These registers are compared with pdishdrev (<<pdishdrev>>), such that the samples are only qualified if the following evaluates to true.

`spdisevmatch` & `spdisevmask` == pdishdrev & `spdisevmask`

NOTE: _For some filtering configurations, such as sampling only select control transfer types, an implementation could optimize this by selecting only control transfer instructions whose type matches one of those selected.  This effectively moves the filtering from sample end to instruction selection, which will improve efficiency by reducing the number of discarded samples._

==== Latency Filtering

Samples can be discarded if a selected latency value does not exceed a chosen threshold.  The `spdisfilter` register is used to select the latency value, and the threshold.  The sample is only qualified if

* `spdislatthread`.INV=0 and selected latency >= `spdisfilter`.THRESH; or
* `spdislatthread`.INV=1 and selected latency < `spdisfilter`.THRESH.

NOTE: _When selecting a latency value for filtering that counts until the sampled instruction retires (i.e., Total latency or Oldest latency), the latency value used in the comparison may be smaller than the value reported in the record.  This is because a precise LCOFI may require some setup time in order to avoid skid, and hence the comparison may occur some fixed number of cycles before retirement._

[[sampmodes]]
=== Sampling Modes

PDIS supports collecting each sample record individually as well as a batch mode, where records accumulate in a memory buffer and are collected only once a buffer threshold is reached.

To collect records individually, local counter overflow interrupts (LCOFIs) are used to notify software when a record is available.  Software initializes PDIS with `mpdisctl`.OF=0.  When a sampled instruction is qualified, the OF bit will transition to 1 and an LCOFI is pended.  The LCOFI handler will observe `scountovf`[1]=1, which indicates a PDIS sample is available.  The handler can then collect the record, from the PDIS Memory Buffer (<<membuff>>) if `mpdisctl`.MEM=1 or from PDIS Sample Data Registers (<<dataregs>>) if `mpdisctl`.MEM=0, along with any other state desired.  It must then clear the PDIS OF flag before resuming workload execution.

To enable batch mode, PDIS is configured with OF=1 and MEM=1 in `mpdisctl`, and with `spdisambcs`.BMIEN=1.  If `mpdisctl`.MEM is hardcoded to 0, batch mode is not supported.  When a sampled instruction is qualified, a sample record will be stored to the PDIS Memory Buffer (<<membuff>>).  Once the buffer write pointer reaches the `spdisambcs`.BMITH threshold, a local asynchronous memory buffer interrupt (LAMBI) is pended with `spdisambcs`.BMI=1.  The LAMBI handler can then collect the records, adjust any other PDIS state if desired, and clear BMI before resuming workload execution.

For both LCOFIs and LAMBIs associated with PDIS, software is advised to inhibit the PDIS counter (`__x__countinhibit`[1]=1) during handler execution.  This avoids counting or sampling handler instructions, and avoids risk of the PDIS sample data registers being modified as the record is being collected.

[[membuff]]
=== Memory Buffer

The PDIS memory buffer is an instance of the Asynchronous Memory Buffer, as defined by the Ssamb extension.  The PDIS memory buffer (PMB) must be implemented if `mpdisctl`.MEM is not hardcoded to 0. All optionality available within the Ssamb extension is available for the PMB.

The PMB is configured using `spdisambcs`, `spdisambaddr`, `menvcfg`.PDISS, and `henvcfg`.PDISV.  See <<pdiscsr>> and the https://github.com/riscv/self-hosted-trace/releases[Self-hosted Trace Specification] for details.

[[perfevents]]
=== Performance Events

The following performance events are available for counting in Zihpm counters.

[cols="25%,75%",options="header"]
|===
| Name | Description
| INST.DEC.SPEC | Instructions decoded
| INST.DEC.BRJMP.SPEC | Control transfer instructions decoded
| INST.DEC.LOAD.SPEC | Load instructions decoded
| INST.DEC.STORE.SPEC | Store instructions decoded
| INST.DEC.LDST.SPEC | Load and/or store instructions decoded
| PDIS.SAMPLES | Qualified samples recorded
| PDIS.COLLISIONS | PDIS counter overflows while a PDIS sample remains active
| PDIS.FILTERED | Samples filtered out
| PDIS.DROPPED | Sample records dropped as a result of backpressure
|===

NOTE: _PDIS.SAMPLES in most cases will match the number of samples collected, but if a circular memory buffer is used some samples may be overwritten.  The total number of PDIS counter overflows can be inferred from PDIS.SAMPLES + PDIS.COLLISIONS + PDIS.FILTERED + PDIS.DROPPED.  The INST.*.SPEC events provide the full sample population from which the selections were chosen._

NOTE: _The RISC-V Hart Performance Events spec includes events like INST.SPEC, which could be counted at decode and hence match INST.DEC.SPEC, or they could be counted further in the pipeline.  The spec doesn't make clear what exactly these events count, hence the INST.DEC.* events defined here._

=== Custom Extensions

No bits within PDIS records are reserved for custom use.  Any record bits listed as WPRI may be used to hold custom fields, with the understanding that they may be reclaimed for standard fields by a future extension.

A custom PDIS extension that alters standard PDIS behavior must be associated with a non-zero value within the designated custom bits in `__x__pdisctl`.  When the custom bits hold a non-zero value that enables a custom extension, the extension may alter standard PDIS behavior, which may include redefining standard record fields.
